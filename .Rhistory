est0 = estimates(X,K,100,1e-4, q,p)
#Packages
#########################################################################
Estep = function(n,K = 3,q = 4,p = 10,
piik,mu, theta2=1,
sigma2=1,
y=y,
Q=Q,
C=C){
alphai =list()
alphai2 =list()
alphai22 =list()
alphai2Q =list()
nn=sum(n)
tau = matrix(0,nn,K)
for (k in 1:K){
Qk=Q[[k]]
muk=mu[[k]]
ez= muk%*%t(rep(1,nn))
vz = theta2 * (Qk%*%t(Qk))+sigma2*diag(p)
for (i in (1:nn)){
tau[i,k] = dmvnorm(y[i,], mean = ez[,i], sigma = vz)*piik[k]}
alphai[[k]] =  theta2*t(Qk) %*%solve(theta2*Qk%*%(t(Qk))+sigma2*diag(p)) %*% (t(y)-muk%*%t(rep(1,nn)))
alphai22[[k]] = matrix(0,ncol=nn,nrow=q*q)
alphai2[[k]] = numeric(nn)
alphai2Q[[k]] = numeric(nn)
for (i in (1:nn)){
alphai2[[k]][i] = sum(diag(theta2*solve(diag(q)+(theta2/sigma2)*t(Qk)%*%Qk)))+sum(alphai[[k]][,i]^2)
alphai2Q[[k]][i] = sum(diag(theta2*Qk%*%solve(diag(q)+(theta2/sigma2)*t(Qk)%*%Qk)%*%t(Qk)))+sum((Qk%*%alphai[[k]][,i])^2)
alphai22[[k]][,i] = as.vector(theta2*solve(diag(q)+(theta2/sigma2)*t(Qk)%*%Qk)+alphai[[k]][,i]%*%t(alphai[[k]][,i]))
}
}
sommetau = apply(tau,1,sum)
tau = tau/sommetau
return(list(alphai=alphai,alphai2=alphai2,alphai22=alphai22,alphai2Q=alphai2Q,tau=tau))
}
Mstep = function(n=c(100,100,100),K = 3,q = 4,p = 10,
y,z,C,muold,alphai,alphai2,alphai22, alphai2Q,tau){
piik = apply(tau,2,mean)
mu = list()
Q = list()
sigma2i = numeric(K)
nn=sum(n)
theta2i = matrix(0,nn,K)
for (k in 1:K){
tauik=tau[,k]
alphaik = alphai[[k]]
alphai2k = alphai2[[k]]
alphai22k = alphai22[[k]]
alphai2Qk = alphai2Q[[k]]
muoldk=muold[[k]]
#tau  = as.numeric(z==k)
y=as.matrix(y)
S1=0
S2=0
for (i in (1:nn)){
theta2i[i,k] =  tauik[i] * (alphai2k[i])
}
S1= 0
S2 = 0
for (i in (1:nn))
{S1 = S1 + tauik[i] * (y[i,] - muoldk) %*%t(alphaik[,i])
S2 = S2 + tauik[i] * matrix(alphai22k[,i],nrow=q,ncol=q)}
Q[[k]]= S1 %*% solve(S2)
mu[[k]] = apply(rep(1,p)%*%t(tauik) * (t(y)-Q[[k]]%*%alphaik),1,sum)/sum(tauik)
#veci = numeric(n)
#for (i in 1:n){ veci[i] = t(t(y[i,]-mu[[k]]))%*%Q[[k]]%*%(alphaik[,i])}
sigma2i[k] = sum(tauik * (diag(t(t(y)-mu[[k]])%*%(t(y)-mu[[k]]))-2*diag(t(t(y)-mu[[k]])%*%Q[[k]]%*%alphaik)+alphai2Q[[k]]))
}
theta2 = (1/(nn*q))*sum(theta2i)
sigma2 = (1/(nn*p))*sum(sigma2i)
sigma2i = sigma2i / nn
return(list(piik=piik, mu=mu,Q=Q,theta2=theta2,sigma2=sigma2,sigma2i=sigma2i))
}
estimates = function(data,
K=3,
maxits=100,
tol=1e-4,
q = 4,
p=10,
verbose=TRUE){
N = dim(data)[1]
y = as.matrix(data[,1:p],N,p)
#initialisation
groupe=1:K
C= sample(groupe,dim(y)[1],replace=TRUE)
piik=rep(1/K,K)
n = as.numeric(summary(as.factor(C)))
mu = list()
for (k in (1:K)){
nk=n[k]
mu[[k]]=apply(y[which(C==k),],2,mean)}
yc = matrix(N*p,N,p)
Q=list()
for (k in (1:K)){
nk=n[k]
yc[which(C==k),]=y[which(C==k),]-matrix(rep(mu[[k]],nk),nk,p,byrow=TRUE)
Q[[k]] = svd(yc[which(C==k),],nu=q,nv=q)$v
}
theta2=1
sigma2=1
#Q=list()
#for (k in (1:K)){Q[[k]]=diag(p)[,1:q]}
#for (k in (1:K)){Q[[k]]=matrix(rep(1,p*q),ncol=q)}
diff = 10
iter=0
loglik=-Inf
cvce=FALSE
while (!cvce && iter < maxits){
old.piik <- piik
old.mu <- mu
old.Q <- Q
old.theta2 <- theta2
old.sigma2 <- sigma2
Estepresults = Estep(n,K,q,p,piik,mu,theta2,sigma2,y,Q,C)
alphai=Estepresults$alphai;
alphai2=Estepresults$alphai2;
alphai22=Estepresults$alphai22;
alphai2Q=Estepresults$alphai2Q;
tau=Estepresults$tau
Mstepresults = Mstep(n,K,q,p,y,z,C,old.mu,alphai,alphai2,alphai22, alphai2Q,tau)
piik=Mstepresults$piik;
mu=Mstepresults$mu;
Q=Mstepresults$Q;
theta2=Mstepresults$theta2;
sigma2=Mstepresults$sigma2;
sigma2i=Mstepresults$sigma2i
diff1=numeric(K)
for (k in (1:K)){diff1[k] = sum((piik[k]-old.piik[k])^2)+sum((mu[[k]] - old.mu[[k]])^2)+sum((Q[[k]] - old.Q[[k]])^2) }
diff = sum(diff1) + sum((theta2-old.theta2)^2)
print(diff)
loglik_old = loglik
k = 1
if ((sigma2i[1]<0) || (sigma2i[2]<0) || (sigma2i[3]<0) || (is.na(sigma2i[1])==TRUE)){loglik = -Inf}else{loglik = ll_mixPCA(y,
mu=mu,
Q=Q,
alphai=alphai,
sigma2i=sigma2i,K,tau)}
if (verbose) {print(paste("iteration",iter,", LL = ",round(loglik,2)))}
cvce = EM_converged(loglik,loglik_old)$converged
iter = iter +1
}
G=numeric(N)
G=apply(tau,1,which.max)
return(list(piik=piik,mu=mu,Q=Q,theta2=theta2,sigma2i=sigma2i,G=G,alphai=alphai))
}
ll_mixPCA = function(X,mu=mu,Q=Q,alphai=alphai,sigma2i=sigma2i,K=K,tau=tau){
N = nrow(X)
p = ncol(X)
tmp=numeric(K)
LL=numeric(K)
for (k in (1:K)){
tmp = (X-matrix(rep(mu[[k]],N),N,p,byrow=TRUE)-t(alphai[[k]])%*%t(Q[[k]]))
LL[k] = -N*p*(log(2*pi)+log(sigma2i[k]))-sum(tau[,k] * diag(tmp%*%t(tmp)))
}
L=sum(LL)
return(L)
}
EM_converged <-
function(loglik, previous_loglik, threshold = 1e-4) {
converged = 0;
decrease = 0;
if(!(previous_loglik==-Inf)){
if (loglik - previous_loglik < -1e-2) # allow for a little imprecision
{
print(paste("******likelihood decreased from ",previous_loglik," to ", loglik,sep=""),quote = FALSE)
decrease = 1;
}
delta_loglik = abs(loglik - previous_loglik);
avg_loglik = (abs(loglik) + abs(previous_loglik) + threshold)/2;
bb = ((delta_loglik/avg_loglik) < threshold)
if (bb) {converged = 1}
}
res <- NULL
res$converged <- converged
res$decrease <- decrease
return(res)
}
data1=data_gen_mixAcp(n=n,K = 3,q = 4,p = 10,
s = s,
pii = pii,
mu = mu,
SNR2 = SNR2,
sigma2 = sigma2)
X=data1$data
covX[,i] = as.vector(cov(X[1:p]))
### Si on utilise le code EM
est0 = estimates(X,K,100,1e-4, q,p)
est1  =   tryCatch(
expr  = {est0 = estimates(X,K,100,1e-4, q,p)
est0}, error  =  function(cond) {
mu=list()
mu[[1]] = rep(NA,p)
mu[[2]] = rep(NA,p)
mu[[3]] = rep(NA,p)
Q=list()
Q[[1]] = rep(NA,p*q)
Q[[2]] = rep(NA,p*q)
Q[[3]] = rep(NA,p*q)
theta2 = NA
sigma2i = list()
sigma2i[[1]] = NA
sigma2i[[2]] = NA
sigma2i[[3]] =NA
G=rep(NA,n)
alphai=list()
alphai[[1]] = rep(NA,n*q)
alphai[[2]] = rep(NA,n*q)
alphai[[3]] = rep(NA,n*q)
list(pik=rep(NA,3),mu=mu,Q=Q,theta2=theta2,sigma2i=sigma2i,G=G,alphai=alphai)
})
if (is.na(est0$piik[1]) ==FALSE){
n1 = as.numeric(which.max(table(est0$G,data1$data$g)[1,]))
n2 = as.numeric(which.max(table(est0$G,data1$data$g)[2,]))
n3 = as.numeric(which.max(table(est0$G,data1$data$g)[3,]))
err[i] = (max(table(est0$G,data1$data$g)[1,])+max(table(est0$G,data1$data$g)[2,])+max(table(est0$G,data1$data$g)[3,]))/n}else{
n1=1;n2=2;n3=3;err[i]=NA
}
Xest0 = matrix(0,n,p)
nn1=length(est0$G[est0$G == 1])
nn2=length(est0$G[est0$G == 2])
nn3=length(est0$G[est0$G == 3])
x1 = data1$data[est0$G == 1,(p+1):(p+nx)]
dim(data1$data)
p
x1 = data1$data[est0$G == 1,1:p]
alphai1 = t(est0$beta[[1]]%*%t(x1)) + matrix(rnorm(nn1*q,mean=0,sd=sqrt(est0$sigma2)),ncol=q)
est0$beta[[1]]%*%t(x1)
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i)*matrix(rnorm(nn1*p),nn1,p)
est1$alphai[[1]]
est0$alphai[[1]]
t(est0$alphai[[1]])%*%t(est0$Q[[1]])
matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i[1])*matrix(rnorm(nn1*p),nn1,p)
dim(t(est0$alphai[[1]])%*%t(est0$Q[[1]]))
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]][est0$G == 1,])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i[1])*matrix(rnorm(nn1*p),nn1,p)
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]][which(est0$G == 1),])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i[1])*matrix(rnorm(nn1*p),nn1,p)
dim(est0$alphai[[1]][which(est0$G == 1),])
dim(est0$alphai[[1]][,])
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]][,which(est0$G == 1)])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i[1])*matrix(rnorm(nn1*p),nn1,p)
Xest0[which(est0$G == 2),1:p]=t(est0$alphai[[2]][,which(est0$G == 2)])%*%t(est0$Q[[2]])+matrix(rep(est0$mu[[2]],nn2),nn2,p,byrow=TRUE)+sqrt(est0$sigma2i[2])*matrix(rnorm(nn2*p),nn2,p)
x1 = data1$data[est0$G == 1,1:p]
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]][,which(est0$G == 1)])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i[1])*matrix(rnorm(nn1*p),nn1,p)
x2 = data1$data[est0$G == 2,1:p]
Xest0[which(est0$G == 2),1:p]=t(est0$alphai[[2]][,which(est0$G == 2)])%*%t(est0$Q[[2]])+matrix(rep(est0$mu[[2]],nn2),nn2,p,byrow=TRUE)+sqrt(est0$sigma2i[2])*matrix(rnorm(nn2*p),nn2,p)
x3 = data1$data[est0$G == 3,1:p]
Xest0[which(est0$G == 3),1:p]=t(est0$alphai[[3]][,which(est0$G == 3)])%*%t(est0$Q[[3]])+matrix(rep(est0$mu[[3]],nn3),nn3,p,byrow=TRUE)+sqrt(est0$sigma2i[3])*matrix(rnorm(nn3*p),nn3,p)
covXest[,i] = as.vector(cov(Xest0))
Xest0 = matrix(0,n,p)
nn1=length(est0$G[est0$G == 1])
nn2=length(est0$G[est0$G == 2])
nn3=length(est0$G[est0$G == 3])
x1 = data1$data[est0$G == 1,1:p]
Xest0[which(est0$G == 1),1:p]=t(est0$alphai[[1]][,which(est0$G == 1)])%*%t(est0$Q[[1]])+matrix(rep(est0$mu[[1]],nn1),nn1,p,byrow=TRUE)+sqrt(est0$sigma2i[1])*matrix(rnorm(nn1*p),nn1,p)
x2 = data1$data[est0$G == 2,1:p]
Xest0[which(est0$G == 2),1:p]=t(est0$alphai[[2]][,which(est0$G == 2)])%*%t(est0$Q[[2]])+matrix(rep(est0$mu[[2]],nn2),nn2,p,byrow=TRUE)+sqrt(est0$sigma2i[2])*matrix(rnorm(nn2*p),nn2,p)
x3 = data1$data[est0$G == 3,1:p]
Xest0[which(est0$G == 3),1:p]=t(est0$alphai[[3]][,which(est0$G == 3)])%*%t(est0$Q[[3]])+matrix(rep(est0$mu[[3]],nn3),nn3,p,byrow=TRUE)+sqrt(est0$sigma2i[3])*matrix(rnorm(nn3*p),nn3,p)
covXest[,i] = as.vector(cov(Xest0))
#Packages
#########################################################################
Estep = function(n,K = 3,q = 4,p = 10,nx=4,
piik,mu,beta, theta2=1,
sigma2=1,
x=x,y=y,
Q=Q,
C=C){
alphai =list()
alphai2 =list()
alphai22 =list()
alphai2Q =list()
nn=sum(n)
tau = matrix(0,nn,K)
for (k in 1:K){
betak=beta[[k]]
Qk=Q[[k]]
muk=mu[[k]]
ez= muk%*%t(rep(1,nn)) + Qk%*%betak%*%t(x)
vz = theta2 * (Qk%*%t(Qk))+sigma2*diag(p)
for (i in (1:nn)){
tau[i,k] = dmvnorm(y[i,], mean = ez[,i], sigma = vz)*piik[k]}
alphai[[k]] = betak%*%t(x) + theta2*t(Qk) %*%solve(theta2*Qk%*%(t(Qk))+sigma2*diag(p)) %*% (t(y)-muk%*%t(rep(1,nn))-Qk%*%betak%*%t(x))
alphai22[[k]] = matrix(0,ncol=nn,nrow=q*q)
alphai2[[k]] = numeric(nn)
alphai2Q[[k]] = numeric(nn)
for (i in (1:nn)){
alphai2[[k]][i] = sum(diag(theta2*solve(diag(q)+(theta2/sigma2)*t(Qk)%*%Qk)))+sum(alphai[[k]][,i]^2)
alphai2Q[[k]][i] = sum(diag(theta2*Qk%*%solve(diag(q)+(theta2/sigma2)*t(Qk)%*%Qk)%*%t(Qk)))+sum((Qk%*%alphai[[k]][,i])^2)
alphai22[[k]][,i] = as.vector(theta2*solve(diag(q)+(theta2/sigma2)*t(Qk)%*%Qk)+alphai[[k]][,i]%*%t(alphai[[k]][,i]))
}
}
sommetau = apply(tau,1,sum)
tau = tau/sommetau
return(list(alphai=alphai,alphai2=alphai2,alphai22=alphai22,alphai2Q=alphai2Q,tau=tau))
}
Mstep = function(n=c(100,100,100),K = 3,q = 4,p = 10,nx=4,
x,y,z,C,muold,alphai,alphai2,alphai22, alphai2Q,tau){
piik = apply(tau,2,mean)
mu = list()
Q = list()
beta=list()
sigma2i = numeric(K)
nn=sum(n)
theta2i = matrix(0,nn,K)
for (k in 1:K){
tauik=tau[,k]
alphaik = alphai[[k]]
alphai2k = alphai2[[k]]
alphai22k = alphai22[[k]]
alphai2Qk = alphai2Q[[k]]
muoldk=muold[[k]]
#tau  = as.numeric(z==k)
x=as.matrix(x)
y=as.matrix(y)
S1=0
S2=0
for (i in (1:nn))
{S1 = S1 + tauik[i] * (x[i,] %*%t(x[i,]))
S2 =S2 + tauik[i] * x[i,] %*%t(alphaik[,i])
}
beta[[k]]= solve(S1)%*%S2
#betak = matrix(as.numeric(beta[[k]]),q,q)
for (i in (1:nn)){
theta2i[i,k] =  tauik[i] * (alphai2k[i]  -2* t(x[i,])%*%t(beta[[k]])%*%alphaik[,i]+t(x[i,])%*%t(beta[[k]])%*%beta[[k]]%*%x[i,])
}
S1= 0
S2 = 0
for (i in (1:nn))
{S1 = S1 + tauik[i] * (y[i,] - muoldk) %*%t(alphaik[,i])
S2 = S2 + tauik[i] * matrix(alphai22k[,i],nrow=q,ncol=q)}
Q[[k]]= S1 %*% solve(S2)
mu[[k]] = apply(rep(1,p)%*%t(tauik) * (t(y)-Q[[k]]%*%alphaik),1,sum)/sum(tauik)
#veci = numeric(nn)
#for (i in 1:nn){ veci[i] = t(t(y[i,]-mu[[k]]))%*%Q[[k]]%*%(alphaik[,i])}
sigma2i[k] = sum(tauik * (diag(t(t(y)-mu[[k]])%*%(t(y)-mu[[k]]))-2*diag(t(t(y)-mu[[k]])%*%Q[[k]]%*%alphaik)+alphai2Q[[k]]))
}
theta2 = (1/(nn*q))*sum(theta2i)
sigma2 = (1/(nn*p))*sum(sigma2i)
sigma2i = sigma2i / nn
return(list(piik=piik,beta = beta, mu=mu,Q=Q,theta2=theta2,sigma2=sigma2,sigma2i=sigma2i))
}
estimates = function(data,K=3,maxits=100,
tol=1e-4,
q = 4,
p=10,
nx=4,
verbose=TRUE){
N = dim(data)[1]
y = as.matrix(data[,1:p],N,p)
x = data[,(p+1):(p+nx)]
#initialisation
groupe=1:K
C= sample(groupe,dim(y)[1],replace=TRUE)
piik=rep(1/K,K)
n = as.numeric(summary(as.factor(C)))
mu = list()
for (k in (1:K)){mu[[k]]=apply(y[which(C==k),],2,mean)}
beta = list()
for (k in (1:K)){beta[[k]]= matrix(rnorm(q*nx,mean=0,sd=2),ncol=nx)}
theta2=1
sigma2=1
Q=list()
#for (k in (1:K)){Q[[k]]=diag(p)[,1:q]}
for (k in (1:K)){Q[[k]]=matrix(rep(1,p*q),ncol=q)}
diff = 10
iter=0
loglik=-Inf
while (diff > tol && iter < maxits){
old.piik <- piik
old.mu <- mu
old.Q <- Q
old.beta <- beta
old.theta2 <- theta2
old.sigma2 <- sigma2
Estepresults = Estep(n,K,q,p,nx,piik,mu,beta,theta2,sigma2,x,y,Q,C)
alphai=Estepresults$alphai;alphai2=Estepresults$alphai2;alphai22=Estepresults$alphai22;alphai2Q=Estepresults$alphai2Q;tau=Estepresults$tau
Mstepresults = Mstep(n,K,q,p,nx=4,x,y,z,C,old.mu,alphai,alphai2,alphai22, alphai2Q,tau)
piik=Mstepresults$piik;beta=Mstepresults$beta;mu=Mstepresults$mu;Q=Mstepresults$Q;theta2=Mstepresults$theta2;sigma2=Mstepresults$sigma2;sigma2i=Mstepresults$sigma2i
diff1=numeric(K)
for (k in (1:K)){diff1[k] = sum((piik[k]-old.piik[k])^2)+sum((mu[[k]] - old.mu[[k]])^2)+sum((Q[[k]] - old.Q[[k]])^2) + sum((beta[[k]] - old.beta[[k]])^2)}
diff = sum(diff1) + sum((theta2-old.theta2)^2) + sum((sigma2-old.sigma2)^2)
print(diff)
loglik_old = loglik
k = 1
if ((sigma2i[1]<0) || (sigma2i[2]<0) || (sigma2i[3]<0)) {loglik = -Inf}else{loglik = ll_mixPCA(y,
mu=mu,
Q=Q,
alphai=alphai,
sigma2i=sigma2i,K,tau)}
if (verbose) {print(paste("iteration",iter,", LL = ",round(loglik,2)))}
cvce = EM_converged(loglik,loglik_old)$converged
iter = iter +1
}
G=numeric(N)
G=apply(tau,1,which.max)
return(list(piik=piik,mu=mu,beta=beta,Q=Q,theta2=theta2,sigma2i=sigma2i,G=G,alphai=alphai))
}
ll_mixPCA = function(X,mu=mu,Q=Q,alphai=alphai,sigma2i=sigma2i,K=K,tau=tau){
N = nrow(X)
p = ncol(X)
tmp=numeric(K)
LL=numeric(K)
for (k in (1:K)){
tmp = (X-matrix(rep(mu[[k]],N),N,p,byrow=TRUE)-t(alphai[[k]])%*%t(Q[[k]]))
LL[k] = -N*p*(log(2*pi)+log(sigma2i[k]))-sum(tau[,k] * diag(tmp%*%t(tmp)))
}
L=sum(LL)
return(L)
}
EM_converged <-
function(loglik, previous_loglik, threshold = 1e-4) {
converged = 0;
decrease = 0;
if(!(previous_loglik==-Inf)){
if (loglik - previous_loglik < -1e-2) # allow for a little imprecision
{
print(paste("******likelihood decreased from ",previous_loglik," to ", loglik,sep=""),quote = FALSE)
decrease = 1;
}
delta_loglik = abs(loglik - previous_loglik);
avg_loglik = (abs(loglik) + abs(previous_loglik) + threshold)/2;
bb = ((delta_loglik/avg_loglik) < threshold)
if (bb) {converged = 1}
}
res <- NULL
res$converged <- converged
res$decrease <- decrease
return(res)
}
q = 4
nx=4
p=10
n = 10000
pii = c(0.2,0.35,0.45) # n'est pas utilisé
mu = matrix(c((0:9)^2/20,2*cos((0:9)/2)+1, rep(1,10)),nrow = 10,ncol=3)
s = matrix(c(0.7,-0.4,0.7,0.4,0.8,0.2),ncol=3,nrow=2)
betat = matrix(rnorm(4*4,mean=0,sd=2),ncol=4)
beta = matrix(rnorm(4*4,mean=0,sd=2),ncol=4)
SNR2 = 3
SNR1 = 100
sig2 = .01
tol = 1e-4
maxit = 100
covXpca = matrix(0,p*p,M)
covXest = matrix(0,p*p,M)
covX = matrix(0,p*p,M)
err= numeric(M)
data1=data_gen(n=n,K = 3,q = 4,p = 10,nx=4,
s = s,
pii = pii,
mu = mu,
beta = beta,
SNR1 = SNR1,
SNR2 = SNR2)
X=data1$data
covX[,i] = as.vector(cov(X[1:p]))
est1  =   tryCatch(
expr  = {est0 = estimates(X,K=3,maxits=100,
tol=1e-4,
q = 4,
p=10,
nx=4,
verbose=TRUE)
est0}, error  =  function(cond) {
mu=list()
mu[[1]] = rep(NA,p)
mu[[2]] = rep(NA,p)
mu[[3]] = rep(NA,p)
beta=list()
beta[[1]] = rep(NA,nx*q)
beta[[2]] = rep(NA,nx*q)
beta[[3]] = rep(NA,nx*q)
Q=list()
Q[[1]] = rep(NA,p*q)
Q[[2]] = rep(NA,p*q)
Q[[3]] = rep(NA,p*q)
theta2 = NA
sigma2i = list()
sigma2i[[1]] = NA
sigma2i[[2]] = NA
sigma2i[[3]] =NA
G=rep(NA,nn)
Q[[1]] = rep(NA,p*q)
Q[[2]] = rep(NA,p*q)
Q[[3]] = rep(NA,p*q)
alphai[[1]] = rep(NA,p*q)
alphai[[2]] = rep(NA,p*q)
alphai[[3]] = rep(NA,p*q)
list(pik=rep(NA,3),mu=mu,beta=beta,Q=Q,theta2=theta2,sigma2i=sigma2i,G=G,alphai=alphai)
})
if (is.na(est0$piik[1]) ==FALSE){
n1 = as.numeric(which.max(table(est0$G,data1$data$g)[1,]))
n2 = as.numeric(which.max(table(est0$G,data1$data$g)[2,]))
n3 = as.numeric(which.max(table(est0$G,data1$data$g)[3,]))
err[i] = (max(table(est0$G,data1$data$g)[1,])+max(table(est0$G,data1$data$g)[2,])+max(table(est0$G,data1$data$g)[3,]))/n}else{
n1=1;n2=2;n3=3;err[i]=NA
}
Xest0 = matrix(0,n,p)
nn1=length(est0$G[est0$G == 1])
nn2=length(est0$G[est0$G == 2])
nn3=length(est0$G[est0$G == 3])
x1 = data1$data[est0$G == 1,(p+1):(p+nx)]
alphai1 = t(est0$beta[[1]]%*%t(x1)) + matrix(rnorm(nn1*q,mean=0,sd=sqrt(est0$sigma2)),ncol=q)
Xest0[which(est0$G == 1),1:p]=rep(1,nn1)%*%t(est0$mu[[1]])+t(est0$Q[[1]]%*%t(alphai1))+matrix(rnorm(p*nn1,mean=0,sd=sqrt(est0$theta2)),ncol=p,nrow=nn1)
x2 = data1$data[est0$G == 2,(p+1):(p+nx)]
alphai2 = t(est0$beta[[2]]%*%t(x2)) + matrix(rnorm(nn2*q,mean=0,sd=sqrt(est0$sigma2)),ncol=q)
Xest0[est0$G == 2,]=rep(1,nn2)%*%t(est0$mu[[2]])+t(est0$Q[[2]]%*%t(alphai2))+matrix(rnorm(p*nn2,mean=0,sd=sqrt(est0$theta2)),ncol=p,nrow=nn2)
x3 = data1$data[est0$G == 3,(p+1):(p+nx)]
alphai3 = t(est0$beta[[3]]%*%t(x3)) + matrix(rnorm(nn3*q,mean=0,sd=sqrt(est0$sigma2)),ncol=q)
Xest0[est0$G == 3,]=rep(1,nn3)%*%t(est0$mu[[3]])+t(est0$Q[[3]]%*%t(alphai3))+matrix(rnorm(p*nn3,mean=0,sd=sqrt(est0$theta2)),ncol=p,nrow=nn3)
covXest[,i] = as.vector(cov(Xest0))
#table(est1$G,data1$data$g)
